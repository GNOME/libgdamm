// -*- C++ -*- //

/* sqlbuilder.h
 *
 * Copyright 2006 libgdamm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or(at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <libgdamm/statement.h>
#include <libgdamm/sqlexpr.h>
#include <libgdamm/sqlstatement.h>

_DEFS(libgdamm,libgda)
_PINCLUDE(glibmm/private/object_p.h)

namespace Gnome
{

namespace Gda
{

_WRAP_ENUM(SqlOperatorType, GdaSqlOperatorType)
_WRAP_ENUM(SqlSelectJoinType, GdaSqlSelectJoinType)
_WRAP_GERROR(SqlBuilderError, GdaSqlBuilderError, GDA_SQL_BUILDER_ERROR)
_WRAP_GERROR(SqlError, GdaSqlError, GDA_SQL_ERROR)

/*
 * @ingroup Connection
 */
class SqlBuilder : public Glib::Object
{
  _CLASS_GOBJECT(SqlBuilder, GdaSqlBuilder, GDA_SQL_BUILDER, Glib::Object, GObject)
protected:
  SqlBuilder(SqlStatementType type);
public:
  _WRAP_CREATE(SqlStatementType type)

  _WRAP_METHOD(Glib::RefPtr<Statement> get_statement() const, gda_sql_builder_get_statement, errthrow)

  //TODO: Remove the stupid copy_it parameter from the C API.
  _WRAP_METHOD(SqlStatement get_sql_statement(bool copy_it), gda_sql_builder_get_sql_statement, errthrow)

  _IGNORE(gda_sql_builder_add_expr, gda_sql_builder_add_param, gda_sql_builder_add_cond)
  _IGNORE(gda_sql_builder_add_cond_v, gda_sql_builder_add_id)
  _IGNORE(gda_sql_builder_add_expr_value)

  // Expression API:

  /** Defines an expression which may be reused to build other parts of a statement.
   * @param string String to use in the SQL
   *
   * @return The ID of the new expression, or 0 if there was an error.
   */
  guint add_id(const Glib::ustring& string);

  /** Defines an expression in Builder which may be reused to build other parts of a statement.
   * @param dh The datahandler to use
   * @param value: value to set the expression to
   *
   * See expr() except that no custom datahandler is given
   *
   * @return The ID of the new expression, or 0 if there was an error.
   */
  template <class ValueType>
  guint add_expr(const Glib::RefPtr<DataHandler>& dh, const ValueType& value);

  /** Defines an expression in Builder which may be reused to build other parts of a statement.
   * @param dh The datahandler to use
   * @param value: value to set the expression to
   *
   * See expr() except that no custom datahandler is given
   *
   * @return The ID of the new expression, or 0 if there was an error.
   */
  guint add_expr_as_value(const Glib::RefPtr<DataHandler>& dh, const Value& value);

  /** Defines an expression in Builder which may be reused to build other parts of a statement.
   * @param value: value to set the expression to
   *
   * See expr() except that no custom datahandler is given
   *
   * @return The ID of the new expression, or 0 if there was an error.
   */
  template <class ValueType>
  guint add_expr(const ValueType& value);

  /** Defines an expression in Builder which may be reused to build other parts of a statement.
   * @param value: value to set the expression to
   *
   * See expr() except that no custom datahandler is given
   *
   * @return The ID of the new expression, or 0 if there was an error.
   */
  guint add_expr_as_value(const Value& value);

  /** Defines a parameter which may be reused to build other parts of a statement.
   * @param: param_name: name of the parameter
   * @type: GType of the parameter
   * @nullok True if the parameter can be set to %NULL
   *
   * @return The ID of the new expression, or 0 if there was an error.
   */
  guint add_param(const Glib::ustring& param_name, GType type, bool nullok = false);

  /** Builds a new expression which reprenents a condition (or operation).
   * @param op Type of condition
   * @param op1 The ID of the 1st argument (not 0)
   * @param op2 The ID of the 2st argument (maybe 0 if op only requires one argument)
   * @param op3 The ID of the 3st argument (maybe 0 if op only requires one or two arguments)
   *
   * @return The ID of the new expression, or 0 if there was an error.
   */
  guint add_cond(SqlOperatorType op, guint op1, guint op2 = 0, guint op3 = 0);

  /** Builds a new expression which reprenents a condition (or operation).
   * @param op Type of condition
   * @param op_ids: list of IDs of the operands of the condition
   *
   * @return The ID of the new expression, or 0 if there was an error.
   */
  guint add_cond(SqlOperatorType op, const Glib::ArrayHandle<guint>& op_ids);

  _IGNORE(gda_sql_builder_add_function, gda_sql_builder_add_function_v)
   _IGNORE(gda_sql_builder_select_join_targets)

  /** Builds a new expression which represents a function applied to some arguments.
    *
    * @param function_name The name of the function to embed (e.g. MAX, MIN, ...)
    * @param args: list of ids of the arguments to the function
    *
    * @return The ID of the new target, or 0 if there was an error.
    */
  guint add_function(const Glib::ustring& function_name, const Glib::ArrayHandle<guint>& args);

    /** Builds a new expression which represents a function applied to an argument.
    *
    * @param function_name The name of the function to embed (e.g. MAX, MIN, ...)
    * @param arg: The ids of the argument to the function
    *
    * @return The ID of the new target, or 0 if there was an error.
    */
  guint add_function(const Glib::ustring& function_name, guint arg);

  _WRAP_METHOD(guint select_add_field(const Glib::ustring& field_name, const Glib::ustring& table_name, const Glib::ustring& alias = Glib::ustring()), gda_sql_builder_select_add_field)

  // Statement API
  /** Adds a new target to a SELECT statement
   * @param table_id The ID of the expression holding a table reference.
   * @param alias The alias to give to the target.
   *
   * @return The ID of the new target, or 0 if there was an error.
   */
  guint select_add_target(const Glib::ustring& table_name, const Glib::ustring& alias = Glib::ustring());

  _IGNORE(gda_sql_builder_select_add_target_id, gda_sql_builder_select_add_target)

  /** Joins two targets in a SELECT statement
   * @param left_target_id The ID of the left target to use (not %0)
   * @param right_target_id The ID of the right target to use (not %0)
   * @param join_type The type of join
   * @param join_expr Joining expression's ID, or %0
   *
   * @return The ID of the new join, or 0 if there was an error.
   */
  guint select_join_targets(guint left_target_id, guint right_target_id, SqlSelectJoinType join_type, guint join_expr = 0);

  _WRAP_METHOD(void join_add_field(guint join_id, const Glib::ustring& field_name), gda_sql_builder_join_add_field)
  _WRAP_METHOD(void select_order_by(guint expr_id, bool asc = true, const Glib::ustring& collation_name = Glib::ustring()), gda_sql_builder_select_order_by)

  /** Adds or removes a DISTINCT clause for a SELECT statement.
   * @param distinct Whether a DISTINCT clause should be in the SELECT statement.
   * @newin4p2
   */
  void select_set_distinct(bool distinct = true);

  _WRAP_METHOD(void select_set_distinct(bool distinct, guint expr_id), gda_sql_builder_select_set_distinct)

  /** Defines the maximum number of rows in the DataModel resulting from the execution of the built statement.
   * @param limit_count The number of rows that should be returned.
   * @param The offset of the first row that should appear in the result. (note that
   * this feature may not be supported by all the database providers.)
  */
  void select_set_limit(guint limit_count, guint offset = 0);

  _WRAP_METHOD(void select_set_limit_id(guint limit_count_expr_id, guint limit_offest_expr_id = 0), gda_sql_builder_select_set_limit)

  _WRAP_METHOD(void select_set_having(guint cond_id), gda_sql_builder_select_set_having)

  _WRAP_METHOD(void select_group_by(guint expr_id), gda_sql_builder_select_group_by)
  //TODO: Add select_group_by_field()?

  // General Statement API
  _WRAP_METHOD(void set_table(const Glib::ustring& table_name), gda_sql_builder_set_table)
  _WRAP_METHOD(void set_where(guint cond_id), gda_sql_builder_set_where)

  _WRAP_METHOD(void add_field_id(guint field_id, guint value_id = 0), gda_sql_builder_add_field_id)

  //TODO: Documentation:
  template <class ValueType>
  void add_field_value(const Glib::ustring& field_name, const ValueType& value);

  _WRAP_METHOD(void add_field_value_as_value(const Glib::ustring& field_name, const Value& value), gda_sql_builder_add_field_value)
  _IGNORE(gda_sql_builder_add_field)


/* COMPOUND SELECT Statement API */
  //TODO: Wrap the enum when we wrap GdaSqlStatementCompound _WRAP_METHOD(void compound_set_type(SqlStatementCompoundType compound_type), gda_sql_builder_compound_set_type)
  //The steal parameter suggests that this is an internal function: _WRAP_METHOD(void compound_add_sub_select(const Glib::RefPtr<SqlStatement>& sqlst, bool steal), gda_sql_builder_compound_add_sub_select)

  _WRAP_METHOD(SqlExpr export_expression(guint id) const, gda_sql_builder_export_expression)

  guint import_expression(const SqlExpr& expr);
  _IGNORE(gda_sql_builder_import_expression)
};

#ifndef DOXYGEN_SHOULD_SKIP_THIS

template <class ValueType> inline
void SqlBuilder::add_field_value(const Glib::ustring& field_name, const ValueType& value)
{
  Gnome::Gda::Value gdavalue(value);
  this->add_field_value_as_value(field_name, gdavalue);
}

template <class ValueType> inline
guint SqlBuilder::add_expr(const Glib::RefPtr<DataHandler>& dh, const ValueType& value)
{
  Gnome::Gda::Value gdavalue(value);
  return this->add_expr_as_value(dh, gdavalue);
}

template <class ValueType> inline
guint SqlBuilder::add_expr(const ValueType& value)
{
  Gnome::Gda::Value gdavalue(value);
  return this->add_expr_as_value(gdavalue);
}

#endif //DOXYGEN_SHOULD_SKIP_THIS

} // namespace Gda
} // namespace Gnome
